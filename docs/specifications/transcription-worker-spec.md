# Technical Specification: Transcription Worker

## Overview
This document provides a detailed technical specification for implementing the Transcription Worker component (Task 6) in the Caption Genie system. The Transcription Worker is responsible for converting audio files to text using cloud-based Speech-to-Text (STT) services.

## Architecture
The Transcription Worker operates as a standalone service that:
1. Consumes jobs from a Redis-backed BullMQ queue
2. Processes audio files generated by the Media Download Worker
3. Sends audio data to a Speech-to-Text service
4. Handles the response and stores the transcript
5. Reports job status and results

## Detailed Component Specifications

### 1. Worker Environment Setup
#### Requirements
- Node.js worker process with TypeScript
- Environment-based configuration for STT credentials
- Health monitoring endpoint
- Process management via PM2

#### Implementation Points
- **Dependency Installation**: Include packages for audio processing (`ffmpeg-static`, `node-audiocontext`), STT clients (`@google-cloud/speech`, `openai`), and queue management (`bullmq`)
- **API Key Management**: Store STT service credentials in environment variables with proper encryption
- **Environment Configuration**: Create typed configuration module for service selection and parameters
- **Service Health Checking**: Implement API availability check before processing
- **Resource Configuration**: Configure memory limits based on expected audio file sizes

### 2. Audio File Processing Pipeline
#### Requirements
- Support for multiple audio formats
- Pre-processing capabilities for optimal STT results
- Segmentation for large files
- Audio normalization

#### Implementation Points
- **Format Validation**: Verify audio format meets STT service requirements
- **Audio Preprocessing**: Apply noise reduction and enhancement techniques
- **Large File Segmentation**: Split audio exceeding service limits (typically 60 seconds)
- **Audio Normalization**: Ensure consistent volume levels across audio samples
- **Speaker Diarization**: Prepare audio for potential speaker identification

### 3. STT Engine Integration
#### Requirements
- Support for multiple STT providers
- Configurable request parameters
- Streaming and batch processing modes
- Custom vocabulary support

#### Implementation Points
- **Service Abstraction Layer**:
  ```typescript
  interface STTService {
    transcribe(audioBuffer: Buffer, options: TranscriptionOptions): Promise<TranscriptionResult>;
    supportsSpeakerDiarization(): boolean;
    supportsStreamingMode(): boolean;
    getMaxAudioDuration(): number;
  }
  
  class GoogleSTTAdapter implements STTService {
    // Implementation
  }
  
  class WhisperSTTAdapter implements STTService {
    // Implementation
  }
  ```
- **Request Configuration**: Define models for STT-specific parameters
- **Service Factory**: Implement factory pattern for service instantiation
- **Custom Dictionary Management**: Support industry-specific terminology

### 4. Transcription Storage System
#### Requirements
- Schema for transcript storage
- Support for timestamps and speaker identification
- Format conversion capabilities

#### Database Schema
```sql
CREATE TABLE transcriptions (
  id SERIAL PRIMARY KEY,
  job_id VARCHAR(50) NOT NULL,
  content TEXT NOT NULL,
  format VARCHAR(10) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  metadata JSONB
);

CREATE TABLE transcript_segments (
  id SERIAL PRIMARY KEY,
  transcription_id INTEGER REFERENCES transcriptions(id),
  start_time FLOAT NOT NULL,
  end_time FLOAT NOT NULL,
  text TEXT NOT NULL,
  speaker_id VARCHAR(10),
  confidence FLOAT
);
```

#### Implementation Points
- **Repository Pattern**: Implement data access layer for transcript management
- **Versioning Support**: Add mechanism for tracking transcript revisions
- **Format Conversion**: Implement utilities for SRT, TXT, and JSON formats
- **Query Optimization**: Add indexes for efficient retrieval by job ID

### 5. Error Handling & Retry Logic
#### Requirements
- Robust error handling
- Configurable retry strategies
- Circuit breaking for service outages
- Support for partial results

#### Implementation Points
- **Error Classification**: Categorize errors by type (network, service, permission, etc.)
- **Retry Strategy**:
  ```typescript
  const retryOptions = {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000
    },
    shouldRetry: (error) => isTransientError(error)
  };
  ```
- **Circuit Breaker**: Implement pattern to prevent cascading failures
- **Partial Results Management**: Save incomplete transcripts when possible
- **Fallback Services**: Switch to alternative provider on failure

## Performance Considerations
- Expected throughput: 10-20 transcription jobs per minute
- Audio file size: Typically 10MB-1GB
- Memory requirements: Minimum 2GB per worker
- Concurrency: Configure worker to process 3-5 jobs simultaneously

## Testing Strategy
1. Unit tests for each component
2. Integration tests with mock STT services
3. Performance tests with various audio file sizes
4. Error handling tests with simulated failures
5. End-to-end tests with real STT providers

## Security Considerations
- STT API keys stored as environment variables, never in code
- Temporary files stored with appropriate permissions
- Audio data encrypted during transmission
- Credentials rotated regularly

## Future Enhancements
- Multi-language support
- Custom acoustic models
- Real-time transcription streaming
- Transcript editing and correction UI 